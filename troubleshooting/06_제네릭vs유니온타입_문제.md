# 제네릭 vs 유니온 타입 오류 문제

## 문제 상황

MainTodo와 SubTodo 타입을 분리한 후, TodoHelpers 함수들의 반환 타입을 정의할 때 오류 발생

```typescript
// 이렇게 하면 App.tsx에서 오류 발생
export function getToggleExpand(
    todoArray: MainTodo[] | SubTodo[], 
    targetId: string
): MainTodo[] | SubTodo[] {
    // ...
}
```

## 오류 내용

```
Argument of type 'MainTodo[] | SubTodo[]' is not assignable to parameter of type 'SetStateAction<MainTodo[]>'.
Type 'SubTodo[]' is not assignable to type 'MainTodo[]'.
```

## 왜 유니온 타입(|)으로 하면 오류가 날까?

### 유니온 타입의 의미
```typescript
MainTodo[] | SubTodo[]
```
이 타입은 "MainTodo[] **또는** SubTodo[]"를 의미합니다.
즉, **런타임에 어느 것이 올지 TypeScript가 확정할 수 없습니다.**

### App.tsx에서의 문제
```typescript
const [todos, setTodos] = useState<MainTodo[]>(...);

function toggleTodo(id: string) {
    const updatedTodos = getToggleExpand(todos, id);  
    // updatedTodos 타입: MainTodo[] | SubTodo[]
    
    setTodos(updatedTodos);  // ❌ 오류!
    // setTodos는 MainTodo[]만 받는데,
    // updatedTodos가 SubTodo[]일 수도 있다고 TypeScript가 판단
}
```

**TypeScript의 관점:**
1. `getToggleExpand`는 `MainTodo[] | SubTodo[]`를 반환
2. 이건 "둘 중 하나"라는 의미
3. `setTodos`는 정확히 `MainTodo[]`만 필요
4. "혹시 `SubTodo[]`일 수도 있잖아?" → **타입 안전성 위반!**

### 실제로는 문제없는데 왜 오류?
```typescript
// 실제 호출
getToggleExpand(todos, id)  // todos는 MainTodo[]

// 우리가 생각하기엔:
// "MainTodo[] 넣었으니까 MainTodo[] 나오겠지?"

// 하지만 함수 시그니처:
// (MainTodo[] | SubTodo[]) => (MainTodo[] | SubTodo[])
// TypeScript는 "입력과 출력의 관계"를 모름!
```

## 제네릭은 왜 오류가 안 날까?

### 제네릭의 의미
```typescript
export function getToggleExpand<T extends MainTodo | SubTodo>(
    todoArray: T[], 
    targetId: string
): T[] {
    // ...
}
```

**제네릭 T의 의미:**
- T는 호출 시점에 **구체적인 타입으로 확정**됨
- "입력과 출력의 타입이 같다"는 관계를 표현

### 타입 추론 과정
```typescript
// App.tsx에서 호출
const todos: MainTodo[] = [...];
const result = getToggleExpand(todos, id);

// TypeScript의 타입 추론:
// 1. todos가 MainTodo[]
// 2. T = MainTodo로 확정
// 3. 반환 타입도 MainTodo[]로 확정
// 4. result 타입: MainTodo[] ✅
```

### 타입 안전성 보장
```typescript
// MainTodo[] 넣으면
getToggleExpand<MainTodo>(mainTodos, id)  // → MainTodo[] 반환

// SubTodo[] 넣으면  
getToggleExpand<SubTodo>(subTodos, id)   // → SubTodo[] 반환

// "입력 타입 = 출력 타입" 관계가 명확!
```

## 핵심 차이점 정리

| 구분 | 유니온 타입 (A \| B) | 제네릭 &lt;T&gt; |
|------|---------------------|---------------|
| **의미** | A 또는 B 중 하나 | 호출 시점에 결정되는 타입 변수 |
| **입출력 관계** | 관계 없음 | 입력 타입 = 출력 타입 |
| **타입 확정** | 런타임까지 불확실 | 호출 시점에 확정 |
| **사용 예** | 여러 타입 모두 받을 때 | 입출력 타입이 같을 때 |

### 비유로 이해하기

**유니온 타입:**
```
함수: "나는 사과 또는 배를 반환할 수 있어"
호출자: "나는 사과만 필요한데, 배가 올 수도 있잖아?"
→ 타입 오류!
```

**제네릭:**
```
함수: "네가 준 과일과 같은 종류를 반환할게"
호출자: "사과 줄게" 
함수: "그럼 사과 반환할게"
→ 타입 안전! ✅
```

## 해결 방법

### 방법 1: 제네릭 사용 (권장)
```typescript
export function getToggleExpand<T extends MainTodo | SubTodo>(
    todoArray: T[], 
    targetId: string
): T[] {
    return todoArray.map(function(todo) {
        if (todo.id === targetId) {
            return { ...todo, isExpanded: !todo.isExpanded };
        }
        if (todo.children && todo.children.length > 0) {
            return { ...todo, children: getToggleExpand(todo.children, targetId) };
        }
        return todo;
    }) as T[];
}
```

### 방법 2: 타입 단언 (비권장)
```typescript
const updatedTodos = getToggleExpand(todos, id) as MainTodo[];
setTodos(updatedTodos);
```
→ 타입 안전성을 우회하는 방법이라 버그 가능성 있음

### 방법 3: 함수 오버로드
```typescript
export function getToggleExpand(todoArray: MainTodo[], targetId: string): MainTodo[];
export function getToggleExpand(todoArray: SubTodo[], targetId: string): SubTodo[];
export function getToggleExpand(todoArray: any[], targetId: string): any[] {
    // 실제 구현
}
```
→ 코드 중복, 유지보수 어려움

## 결론

**제네릭을 사용해야 하는 이유:**
1. ✅ 입력과 출력의 타입 관계를 명확히 표현
2. ✅ 타입 안전성 보장
3. ✅ 코드 재사용성과 유연성
4. ✅ 컴파일 타임에 타입 확정

**유니온 타입의 한계:**
1. ❌ 입출력 타입 관계 표현 불가
2. ❌ "또는"의 의미 때문에 타입 불확실성
3. ❌ 엄격한 타입 체크에서 오류 발생

## 적용된 함수들
- `getAddChildTodo`
- `getDeleteTodo`
- `getToggleTodo`
- `getEditTodo`
- `getToggleExpand`
- `updateParentCompleted`
- `setAllChildrenCompleted`

