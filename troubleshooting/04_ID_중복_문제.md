# ID 중복 문제

## 문제 상황

### 문제 1: `todos.length + 1` 방식의 ID 중복
초기에는 배열의 길이를 기반으로 ID를 생성했습니다.

```typescript
// ❌ 문제가 있던 방식
const newId = 't' + (todos.length + 1);
```

**문제점:**
리스트가 추가되고 삭제되는 과정에서 배열 길이가 달라지므로 **키가 겹치는 문제**가 발생했습니다.


### 문제 2: 하위 누적 개수 방식의 한계
부모 항목이 하위의 누적 개수를 저장하는 방식도 고려했습니다.

```typescript
// ❌ 고려했던 방식
const newChildId = parentId + '_' + (누적 카운트);
```

**문제점:**
- 각 부모가 자신의 하위 개수를 저장할 수 있지만
- **최상위 항목에 대해서는 개수 총합을 state에 저장할 수가 없음**

## 해결 방법

### 타임스탬프 기반 고유 ID 생성

**현재 시간(밀리초)**을 사용하여 고유한 ID를 만들었습니다.

```typescript
// ✅ 해결 방법
const newId = `t_${Date.now()}`;
```

### 적용 코드

#### 최상위 항목 추가
```typescript
function addTodo() {
    if (inputText.trim() === '') return;

    const newId = `t_${Date.now()}`;

    const newTodo = {
        id: newId,
        text: inputText,
        completed: false,
        isExpanded: true,
        children: []
    };

    setTodos([...todos, newTodo]);
    setInputText('');
}
```

#### 하위 항목 추가
```typescript
export function getAddChildTodo(todoArray: Todo[], parentId: string, childText: string): Todo[] {
    return todoArray.map(function(todo) {
        if (todo.id === parentId) {
            const newChildId = `t_${Date.now()}`;
            const newChild = {
                id: newChildId,
                text: childText,
                completed: false,
                isExpanded: true,
                children: []
            };
            return { ...todo, children: [...todo.children, newChild] };
        }
        if (todo.children && todo.children.length > 0) {
            return { ...todo, children: getAddChildTodo(todo.children, parentId, childText) };
        }
        return todo;
    });
}
```

## 결과

- ✅ **항상 고유한 ID 보장** (시간은 계속 증가)
- ✅ 삭제 후 추가해도 중복 없음
- ✅ 외부 라이브러리 불필요
- ✅ 구현이 간단
- ✅ ID만 봐도 생성 순서를 알 수 있음

